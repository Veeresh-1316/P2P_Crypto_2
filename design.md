# CS765 Assignment-1
## Simulation of a P2P Cryptocurrency Network

- Based on Python
- **Hyperparameters:**
  - N : the number of peers in the network
  - z0 : the %age of peers with slow network 
  - z1 : the %age of peers with low cpu power
  - interarrival_mean_time(Ttx) : roughly represents the inter-time between generation of transactions by a peer
  - inrerarrival_mean_block_time(I) : (I/hash_power) roughly represents the inter-time between creation of blocks by a peer
  - hash_ratio : peers with high cpu have 10 times more hashing power than others with low cpu
  - maximum_transactions_per_block : maximum allowed transactions per block including coinbase (1000 = 1MB/1KB)
  - COINBASE_COINS_PER_TRANSACTION : 50

- **Simulation & Initialization**
  - simpy_simulation_time : the time for which the transactions are generated by every peer
  - full_simulation_time : the time until which block generation occurse (even after transactions stop)
  - rho : value corresponding to speed of light propagation delay (randomly initialized between 10ms and 500ms at start)
  - peers : list of all peers in network
  - Network : the graph representing the connected network of all peers
  - We use simpy library to simulate transactions created by every peer at random times (this thread runs independently)

- **Transaction class:**
  - Class for storing every transaction
  - timestamp - the time of creation of the transaction
  - txid - unique transaction id of every transaction : hash of a random number, along with the timestamp
  - sender - the sender of the transaction
  - receiver - the receiver of the transaction
  - coins - number of coins being transferred from sender to receiver
  - **REPRESENTATION** - "{TxID}: {sender} pays {receiver} {coins} coins"
  - size of transaction - **1KB**

- **CoinBaseTransaction:**
  - Subclass of Transaction class
  - Class for storing the CoinBase transaction which is at the start of every Block
  - sender stored as NONE for easy access
  - **REPRESENTATION** - "{TxID}: {receievr} mines {coins} coins"

- **Block:**
  - Class for representing a block in the blockchain
  - blkid - unique block id : hash of prev_blkid, creation_time and tansations included
  - prev_blkid - the block id of the pevious block in the blockchain
  - creation_time - the time at which the block was created and published
  - transactions - list of all the transactions the block encompasses
  - miner_id - id of peer who created this block
  - size of block - **(number of transactions) * 1KB** (upto a maximum size of 1MB) (including coinbase transaction)
  
- **BlockChain:**
  - Class which stores the blockchain as observed by every peer
  - GENESIS_BLOCK - the genesis block of the blockchain (0th block)
  - blocks_all - all blocks in blockahain : dict() from blkid to the block object
  - unadded_blocks - blocks received which cannot be added to the blockchain as of yet : set()
  - all_transactions - all transactions part of the blockcahin
  - txn_pool - transactions part of the longest chain in the blockchain
  - depth - the depth(or length) of the block in the blockchain
  - balances - balances of all peers as calculated at a block (based on transactions in the chain from that block to GENESIS_BLOCK)
  - longest_length - the length of the longest chain in blockchain (excluding GENESIS_BLOCK)
  - longest_block - the block at the end of the longest chain
  - peer - the peer class to which this blockchain belongs
  - blocks_in_longest_chain  - number of blocks created by this peer belonging to the longest chain
  - total_blocks_generated - total number of blocks generated by this peer in the blockchain

- **Peer:**
  - Class to represent the peers who are part of the network
  - speed - denotes the speed of his network (fast or slow)
  - cpu - denotes the power of his cpu (low or high)
  - id - uniquely identifies every peer in the network
  - transactions - all trnsactions initiated by the peer
  - received_blocks - all blocks which are bradcasted by the peer (created and received)
  - received_transactions - all transactions which are bradcasted by the peer (created and received)
  - connections - list of peers he is connected to in the network
  - blockchain - the blockchain as seen by the peer
  - hash_power - %age of hashing power the peer has

### Connected graph generation

We used a slightly greedy approach to construct a connected graph where every peer is connected to 3 to 6 peers:
- For every node, generate a random number **n** between 3 and 6
- Connect the node to **n** other random peers in the network, not already connected to, making sure that the connection number of the other peers doesn't exceed 6.
- If it cannot connect to that many other peers, the graph generation restarts
- If at the end of the graph creation, the graph is not connected, the graph generation process is restarted again until we get a conencted graph
  
The algorithm is implemented in the 'graph.py' file, which is used by the main code.

We used the networkx library to store and print the graph so generated.

### EventQueue

We are maintaining two event schedulers, one for latency simulation, one for block mining simulation:
- scheduler = PriorityQueueScheduler()
  - This is the event handler which handles the event of transaction and block receival by target peer after some calculated latency.
  - Transactions to be forwarded to other peers connected to you, are put in this event queue to reach the other peer after the specifed latency time
  - This mimics the transmission latency between the peers

- block_publisher = PriorityQueueScheduler1()
  - This is the event handler which simulates the block creation time.
  - After the random Tk is calculated for a generated block, an event is inserted into the handler which checks the block after Tk time, to see if its still valid to be published into the blockchain

### Working of the Blockchain

- Transaction creation:
  - every peer generates transactions randomly at times chosen from an exponential distribution whose mean tim is Ttx
  - he publishes the transactions to every connected peer
- Transaction and Block forwarding:
  - the latency of transmission from peer i to peer j is calculated using L = rho + |m|/cij + dij
    - cij : link speed based on network speed of both peers
    - dij : randomly chosen from an exponential distribution of mean 96Kb/cij
- Block generation:
  - Every peer creates a block on the longest chain and publishes it after time Tk (through the event handler)
  - when the publish time arrives, he checks if the lngest chain has changed since or not, by comparing longest_block and prev_blkid. If it hasn't changed, he publishes the block and forwards it. If it changes, the block is discarded.
- Block Receiving:
  - If a peer receives a new block, he checks first if its parent is in the blockchain. If not, he puts it into unadded_transactions to be handled later. If yes, he validates the transactions in the block based on the peer balances at the parent block. If it is valid, it is added into the blockchain, and also blocks in the unadded_list, whose parent is this block, are also similarly validated and added. If it is invalid, the block is dropped and every block in the unadded_list whose parent is this new block are also dropped recursively.
  - If a new valid block added to the blockchain changes the longest chain in the blockchain, updates have to be made. The length and leaf node of longest chain is updated. And also all transactions in blocks in the fork of old longest chain are invalidated (ready to be included in a new block). And all transactions in blocks in new fork thus created are made valid.

### The Tree of Blockchain
At the end of the simulation, the blockchain network thus formed at every peer is printed into a file called 'blockchain_{id}.png', in the 'fig/' directory.

We use Digraph from graphviz library to represent and print the blockchain tree.

The tree is represented by the **'block_all'** dictionary variable of the Blockchain class for every Peer.

### Experiments
Experiments and their results are listed in the report document. The ratio of the number of blocks generated by each node in the Longest Chain of the tree to the total number of blocks it generates at the end of the simulation, is maintained and printed out at the end.

And the relation between the hyperparamters and ratio is observed.

The relation between the hyperparamters and the forks and longest chains are also observed.