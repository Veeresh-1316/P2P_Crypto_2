# CS765 Assignment-2
## Simulating a double selfish mining attack using the P2P Cryptocurrency Network developed in the last assignment

- Based on Python
- **Hyperparameters:**
  - N : the number of honest peers in the network
  - h1 : the %age of hashing power with selfish miner 1
  - h2 : the %age of hashing power with selfish miner 2
  - interarrival_mean_time(Ttx) : roughly represents the inter-time between generation of transactions by a peer
  - inrerarrival_mean_block_time(I) : (I/hash_power) roughly represents the inter-time between creation of blocks by a peer
  - maximum_transactions_per_block : maximum allowed transactions per block including coinbase (1000 = 1MB/1KB)
  - COINBASE_COINS_PER_TRANSACTION : 50

- **Simulation & Initialization**
  - simpy_simulation_time : the time for which the transactions are generated by every peer
  - full_simulation_time : the time until which block generation occurse (even after transactions stop)
  - rho : value corresponding to speed of light propagation delay (randomly initialized between 10ms and 500ms at start)
  - peers : list of all peers in network
  - Network : the graph representing the connected network of all peers
  - We use simpy library to simulate transactions created by every peer at random times (this thread runs independently)

- **Transaction class:**
  - Class for storing every transaction
  - timestamp - the time of creation of the transaction
  - txid - unique transaction id of every transaction : hash of a random number, along with the timestamp
  - sender - the sender of the transaction
  - receiver - the receiver of the transaction
  - coins - number of coins being transferred from sender to receiver
  - **REPRESENTATION** - "{TxID}: {sender} pays {receiver} {coins} coins"
  - size of transaction - **1KB**

- **CoinBaseTransaction:**
  - Subclass of Transaction class
  - Class for storing the CoinBase transaction which is at the start of every Block
  - sender stored as NONE for easy access
  - **REPRESENTATION** - "{TxID}: {receievr} mines {coins} coins"

- **Block:**
  - Class for representing a block in the blockchain
  - blkid - unique block id : hash of prev_blkid, creation_time and tansations included
  - prev_blkid - the block id of the pevious block in the blockchain
  - creation_time - the time at which the block was created and published
  - transactions - list of all the transactions the block encompasses
  - miner_id - id of peer who created this block
  - size of block - **(number of transactions) * 1KB** (upto a maximum size of 1MB) (including coinbase transaction)
  
- **BlockChain:**
  - Class which stores the blockchain as observed by every peer
  - GENESIS_BLOCK - the genesis block of the blockchain (0th block)
  - blocks_all - all blocks in blockahain : dict() from blkid to the block object
  - unadded_blocks - blocks received which cannot be added to the blockchain as of yet : set()
  - all_transactions - all transactions part of the blockcahin
  - txn_pool - transactions part of the longest chain in the blockchain
  - depth - the depth(or length) of the block in the blockchain
  - balances - balances of all peers as calculated at a block (based on transactions in the chain from that block to GENESIS_BLOCK)
  - longest_length - the length of the longest chain in blockchain (excluding GENESIS_BLOCK)
  - longest_block - the block at the end of the longest chain
  - peer - the peer class to which this blockchain belongs
  - blocks_in_longest_chain  - number of blocks created by this peer belonging to the longest chain
  - total_blocks_generated - total number of blocks generated by this peer in the blockchain

- **Peer:**
  - Class to represent the peers who are part of the network
  - speed - denotes the speed of his network (fast or slow)
  - cpu - denotes the power of his cpu (low or high)
  - id - uniquely identifies every peer in the network
  - transactions - all trnsactions initiated by the peer
  - received_blocks - all blocks which are bradcasted by the peer (created and received)
  - received_transactions - all transactions which are bradcasted by the peer (created and received)
  - connections - list of peers he is connected to in the network
  - blockchain - the blockchain as seen by the peer
  - hash_power - %age of hashing power the peer has

- **Selfish_Miner(Peer):**
  - Class subclasses from Peer class, reprsenting the selfish miners in the network
  - private_lead - the lead of the private chain of selfish miner over the public chain
  - private_longest_block - the block on which the selfish miner mines (the last block in private queue OR a block in public chain)
  - private_queue - the private unpublished blocks mined by the miner
  

### Connected graph generation

We used a slightly greedy approach to construct a connected graph where every peer is connected to 3 to 6 peers:
- For every node, generate a random number **n** between 3 and 6
- Connect the node to **n** other random peers in the network, not already connected to, making sure that the connection number of the other peers doesn't exceed 6.
- If it cannot connect to that many other peers, the graph generation restarts
- If at the end of the graph creation, the graph is not connected, the graph generation process is restarted again until we get a conencted graph
  
The algorithm is implemented in the 'graph.py' file, which is used by the main code.

We used the networkx library to store and print the graph so generated.

### EventQueue

- We are using python's inbuilt async - await functionalities to mimic the event queue simulation.
- Whenever a new function must be called parallelly, asyncio.create_task(function()) is called, and the rest is automatically handled.
- This is needed for Block and Transaction forwardingwith delay to neighbour peers, and also to mimic block creation delay.
- The delay is simulated by using 'await asyncio.sleep(delay)'.

### Working of the Blockchain (HONEST MINER)

- Transaction creation:
  - every peer generates transactions randomly at times chosen from an exponential distribution whose mean tim is Ttx
  - he publishes the transactions to every connected peer
- Transaction and Block forwarding:
  - the latency of transmission from peer i to peer j is calculated using L = rho + |m|/cij + dij
    - cij : link speed based on network speed of both peers
    - dij : randomly chosen from an exponential distribution of mean 96Kb/cij
- Block generation:
  - Every peer creates a block on the longest chain and publishes it after time Tk (through the event handler)
  - when the publish time arrives, he checks if the lngest chain has changed since or not, by comparing longest_block and prev_blkid. If it hasn't changed, he publishes the block and forwards it. If it changes, the block is discarded.
- Block Receiving:
  - If a peer receives a new block, he checks first if its parent is in the blockchain. If not, he puts it into unadded_transactions to be handled later. If yes, he validates the transactions in the block based on the peer balances at the parent block. If it is valid, it is added into the blockchain, and also blocks in the unadded_list, whose parent is this block, are also similarly validated and added. If it is invalid, the block is dropped and every block in the unadded_list whose parent is this new block are also dropped recursively.
  - If a new valid block added to the blockchain changes the longest chain in the blockchain, updates have to be made. The length and leaf node of longest chain is updated. And also all transactions in blocks in the fork of old longest chain are invalidated (ready to be included in a new block). And all transactions in blocks in new fork thus created are made valid.

### Working of the Blockchain (SELFISH MINER)

- Selfish miner does not create transactions
- Does not forward transactions
- Mines blocks privately and stores in a private queue, and publishes them as and when required
- Private Block Publish:
  - When the longest public chain changes in length, a release_block() function is called
  - the lead of private chain over public chain is evaluated
  - if the lead < 0 => public chain is ahead, starts a new attack on the last block of the longest chain visible
  - if lead becomes 0, he publishes the blocks in private queue, and continues to mine on top of his own block
  - if lead becomes 1, he publishes the blocks in private queue, and mines on the longest chain visible, i.e. his own private queue
  - if lead > 1, he publishes only 1 block from the private queue, and continues building his own private queue

### The Tree of Blockchain
At the end of the simulation, the blockchain network thus formed at every peer is printed into a file called 'blockchain_{id}.png', in the 'fig/' directory.

We use Digraph from graphviz library to represent and print the blockchain tree.
- The honest blocks are represented by 'lightgrey' color, blocks mined by selfish miner 1 by 'lightblue' color and blocks mined by selfish miner 2 by 'red' color, for effective visualization.
- The blocks in the longest chain for a peer are also bordered 'yellow'.
- For the selfish miners, the number of unpublished blocks are also displayed

The tree is represented by the **'block_all'** dictionary variable of the Blockchain class for every Peer.

### Experiments
- Experiments and their results are listed in the report document.
- The number of blocks generated by each node in the Longest Chain of the tree, and the total number of blocks it generates, is maintained and printed periodically.
- The ratio MPU_node_adv = (Number of block mined by an adversary in final public main chain) / (Total number of blocks mined by this adversary overall) and the ration MPU_node_overall = (Number of block in the final public main chain) / (Total number of blocks generated across all the nodes) are calculated and printed periodically
- And the relation between the hyperparamters and these ratio are observed.